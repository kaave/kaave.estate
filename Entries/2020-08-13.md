---
- title: TypeScript ã§ Result ã£ã½ã„ã‚‚ã®ã‚’å‹ã§è¡¨ç¾ã—ã‚ˆã†ã¨ã—ã¦è©°ã¾ã£ã¦ã„ã‚‹ãŠè©±
- description: TypeScript ã§ Result ã£ã½ã„ã‚‚ã®ã‚’å‹ã§è¡¨ç¾ã—ã‚ˆã†ã¨ã—ã¦è©°ã¾ã£ã¦ã„ã‚‹ãŠè©±ã§ã™ã€‚
- published: true
- tags:
    - typescript
---

Rust ã§ã„ã† `Result<T, E>` ãŒæ¬²ã—ããªã‚Šå‹ã‚’è€ƒãˆã¦ã¿ãŸã‚“ã§ã™ã‘ã©è©°ã¾ã£ã¦ã‚‹ã‹ã‚‰ã¨ã‚Šã‚ãˆãšåãå‡ºã—ã¡ã‚ƒã„ã¾ã™ã€‚è‡ªåˆ†ã®ãƒ–ãƒ­ã‚°ã ã—ã€‚

---

### ã‚³ãƒ¼ãƒ‰

Rust ã«ãªã‚‰ã£ã¦ã“ã‚“ãªå‹ã‚’ç”¨æ„ã—ã¾ã™ã€‚

```ts
// result.ts

export type Ok<T> = { type: 'ok'; value: T };
export type Err<E extends Error> = { type: 'err'; error: E };
export type Result<T, E extends Error> = Ok<T> | Err<E>;
```

ã§ã€ `User defined type guard` ä½¿ã£ã¦ä¾¿åˆ©é–¢æ•°ã‚‚ç”¨æ„ã—ã¾ã™ã€‚

```ts
export const isOk = <T, E extends Error>(r: Result<T, E>): r is Ok<T> => r.type === 'ok';
export const isErr = <T, E extends Error>(r: Result<T, E>): r is Err<E> => r.type === 'err';
```

ãã†ã™ã‚‹ã¨ã“ã†ã„ã†ã“ã¨ãŒã§ãã¾ã™ã‚ˆã­ã€‚

```ts
// å‚è€ƒå€¤ã‚’ä½œæˆã™ã‚‹é–¢æ•°
// ã‚„ã‚„ã“ã—ãã—ãŸã„ã®ã§ç„¡é§„ã« async
async function getResult(): Promise<Result<number, Error>> {
  const result = await new Promise<number>((resolve) => setTimeout(() => resolve(Math.random()), 1000)).catch(
    () => new Error('timeout'),
  );

  return typeof result !== 'number'
    ? { type: 'err', error: result }
    : result < 0.5
    ? { type: 'err', error: new Error(`Invalid range: ${Math.random()}`) }
    : { type: 'ok', value: result };
}

async function main() {
  const r = await getResult();

  if (isOk(r)) {
    console.log(r.value, r.details);
    // console.error(r.error); // type error
  } else {
    // console.log(r.value); // type error
    console.error(r.error, r.details);
  }
}
```

ãŠã»ã»ã€å¤§å¤‰ã‚ˆã‚ã—ã§ã™ã­ ğŸ˜Šï¼ˆã“ã“ã¾ã§ã¯ï¼‰

### ã“ã“ã‹ã‚‰ãŒæ‚©ã¿

å®Ÿæˆ¦ã§ã¯å¿…ãšã¾ã¨ã‚ã¦å‡¦ç†ã—ãŸããªã‚‹ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ãŒã‚ã‚‹ã¨æ€ã†ã‚“ã§ã™ã‚ˆã­ã€‚

```ts
async function main() {
  const results = await Promise.all([getResult(), getResult()]);

  // ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡ğŸ‘‡
  if (isEveryOk(results)) {
    console.log(results.map((r) => r.value));
  } else {
    console.error(results.map((r) => r.error));
  }
}
```

ã“ã® `isEveryOk` ã‚’ã©ã†å®šç¾©ã—ãŸã‚‚ã®ã‹ãŒã‚ã‹ã‚‰ãªã„ã§ã™ã€‚
ä¸€å¿œã“ã“ã¾ã§ã¯é ‘å¼µã£ãŸã£ã¦ã‚„ã¤ã‚’æ›¸ãã¾ã™ã¨â€¦

```ts
/** Result<T, E>[] ã‚’ Ok<T>[] ã¾ãŸã¯ Err<E>[] ã«å¤‰æ›ã™ã‚‹ */
type ExtractResults<T extends Result<any, Error>[], A extends 'ok' | 'err'> = {
  [K in keyof T]: T[K] extends Result<infer P, infer Q> ? (A extends 'ok' ? Ok<P> : Err<Q>) : never;
};

/* ã‚¨ãƒ©ãƒ¼

A type predicate's type must be assignable to its parameter's type.
  Type 'ExtractResults<T, "ok">' is not assignable to type 'T'.
    'ExtractResults<T, "ok">' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'Result<any, Error>[]'.
      Type 'T[K] extends Result<infer P, infer Q> ? Ok<P> : never' is not assignable to type 'T[K]'.
        Type 'Ok<unknown>' is not assignable to type 'T[K]'.ts(2677)

ï¾„ï¾‰ï½ºï¾„
 */
const isEveryOk = <T extends Result<any, Error>[]>(t: T): t is ExtractResults<T, 'ok'> =>
  t.every((r) => r.type === 'ok');
```

ã†ã€œã‚“ã€ã©ã†ã—ãŸã‚‰è‰¯ã„ã®ã§ã—ã‚‡ã†ã‹â€¦ã€‚
ã‹ãªã‚Šæƒœã—ã„ã¨ã“ã‚ã¾ã§ã„ã£ãŸï¼ˆã¤ã‚‚ã‚Šï¼‰ã®ã§ã€ãªã‚“ã¨ã‹ã„ã„æ„Ÿã˜ã«ã—ãŸã„ãªãã¨æ€ã£ã¦ã¾ã™ã­ã€‚
